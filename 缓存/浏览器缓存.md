
**浏览器中缓存可分为强缓存和协商缓存**：

# 强缓存

1）浏览器在加载资源时，先根据这个资源的一些http  
header判断它是否命中强缓存，**强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器**。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；

2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，**通过服务器端依据资源的另外一些http  
header验证这个资源是否命中协商缓存**，如果协商缓存命中，服务器会将这个请求返回，**但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源**，于是浏览器就又会从自己的缓存中去加载这个资源；

3）强缓存与协商缓存的共同点是：**如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据**；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器**。

4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

**当浏览器对某个资源的请求命中了强缓存时，**返回的HTTP状态为200**，在chrome的开发者工具的network里面  **size会显示为from cache****

## Expires

**Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示**，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权

-   浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header，如：
    
    ![response的header加上Expires](https://user-gold-cdn.xitu.io/2018/9/8/165b74cf04b04c8a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
-   浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；
    
-   浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较**，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；
    
-   如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；
    
    ## Cache-Control
    
    -   浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header，如：
    
    ![response的header加上Cache-Control](https://user-gold-cdn.xitu.io/2018/9/8/165b74cf19190d29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
-   浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；
    
-   浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期**，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；
    
-   如果缓存没有命中，浏览器直接从服务器加载资源时，**Cache-Control Header在重新加载的时候会被更新**；
    

**Cache-Control描述的是一个相对时间**，在进行缓存命中的时候，**都是利用客户端时间进行判断**，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。

这两个header可以只启用一个，也可以同时启用，**当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires**：

![Cache-Control优先级高于Expires](https://user-gold-cdn.xitu.io/2018/9/8/165b74cf18869548?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

此外，还可以为 Cache-Control 指定  `public`  或  `private`  标记。**如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源**。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。**对于 public，则允许所有服务器缓存该资源**。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），**Cache-Control 默认设为 public 是合理的**。

# 协商缓存

当浏览器对某个资源的请求没有命中强缓存，**就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串**

**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的**

#### Last-Modified，If-Modified-Since：

-   浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，**在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间**：
    
    ![response的header加上Last-Modified](https://user-gold-cdn.xitu.io/2018/9/8/165b74d0480c1ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
-   浏览器再次跟服务器请求这个资源时，**在request的header上加上If-Modified-Since的header**，这个header的值就是上一次请求时返回的Last-Modified的值：
    
    ![request的header上加上If-Modified-Since](https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d4fbf77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
-   服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化**，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。**当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header**，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：
    
     ![服务器响应304 Not Modified](https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d37cc80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
-   浏览器收到304的响应后，就会从缓存中加载资源。
    
-   如果协商缓存没有命中，浏览器直接从服务器加载资源时，**Last-Modified Header在重新加载的时候会被更新**，下次请求时，**If-Modified-Since会启用上次返回的Last-Modified值**。
    

#### ETag、If-None-Match：

1.  浏览器第一次跟服务器请求一个资源，**服务器在返回这个资源的同时，在response的header加上ETag的header**，这个header是服务器根据当前请求的资源生成的一个唯一标识，**这个唯一标识是一个字符串，只要资源有变化这个串就不同**，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：
    
    ![在response的header加上ETag](https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e587fdf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
2.  浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match的header**，这个header的值就是上一次请求时返回的ETag的值：
    
    ![在request的header上加上If-None-Match](https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d5f4171?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
3.  服务器再次收到资源请求时，**根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag**，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回**，即使这个ETag跟之前的没有变化：
    
    ![由于ETag重新生成过，response header中还会把这个ETag返回](https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e5592563?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
4.  浏览器收到304的响应后，就会从缓存中加载资源。
    

Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。**但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改**，从而在实际操作中实用程度也更高。

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：

![浏览器缓存判断流程](https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e55dda0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

参考：[浏览器缓存](https://juejin.im/post/5b9346dcf265da0aac6fbe57)

# 浏览器缓存存储位置

### 1.Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的**。

service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

**ps: 感觉servicv worker 不怎么常使用**

### 2.Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。  **一旦我们关闭 Tab 页面，内存中的缓存也就被释放了**。

### 3.Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上**。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。

**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**  
关于这点，网上说法不一，不过以下观点比较靠得住：

-   对于大文件来说，大概率是不存储在内存中的，反之优先
-   当前系统内存使用率高的话，文件优先存储进硬盘

## 缓存过程分析

![第一次发起HTTP请求](https://camo.githubusercontent.com/ddcaf3e675377ab08192b776f2025869e9d8ca5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264363935653735313f773d36373026683d35313226663d706e6726733d313635313332)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3OTQ3Mjg1MDIsLTE4MzE4MDIwMjBdfQ
==
-->