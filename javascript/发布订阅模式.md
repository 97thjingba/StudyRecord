## 1.现实世界中的发布订阅模式

小a最近看上了一套房子，到了售楼处被告知房子卖完了。售楼MM告诉小明，以后还会推出新的楼盘，但不知道什么时候推出。于是小明记下了售楼MM的电话，每天打电话去问售楼MM新楼盘的情况。

同样操作的还有小b、小c等。

这种情况在现实中当然不会出现，现实中更可能的是小a、小b、小c留下自己的电话给售楼MM，一旦新的楼盘出来了，售楼MM就会一个一个打电话去通知小a、小b、小c。

在这个情景中，小a、小b、小c就是订阅者，售楼MM就是发布者。

在异步编程中短轮询和长轮询就对应上述的两种情况。

## 2.发布订阅模式的作用

在上面这个例子中，发布订阅模式有着明显的优点。

-   购房者不需要每天打电话给售楼MM询问新房开售时间，在合适的时间，售楼MM会通知这些消息订阅者。
-   购房者和售楼处不再紧密耦合在一起。当有新的购房者出现时，他只需要把电话号码留在售楼处，售楼处也不会关心购房者的任何情况。以后无论购买者还是售楼处发生了什么事情，都不会影响这个过程。只要售楼处记得在合适的时间通知购房者。

第一点广泛用于异步编程中，这是一种代替传统回调函数的手段。比如我们监听异步请求的success和error事件。当事件来临的时候，发布一个状态，那么对此感兴趣的订阅者就会收到这个状态并执行相关操作。

第二点在程序方面带来的好处是可以改变对象之间的硬编码的通知机制。一个对象不再显式地去调用另外一个对象的某个接口。发布订阅模式将两个对象松耦合地联系在一起，虽然不清除彼此细节，但并不影响彼此通信。无论发布者还是订阅者发生了变化，只要它们之间的约定没有变，就没有关系。

## 3.常见的发布订阅模式--DOM事件

`window.addEventListener`就是一个典型的例子。

```
document.body.addEventListener('click', fn1);
document.body.addEventListener('click', fn2);
document.body.addEventListener('click', fn3);
复制代码
```

用户可能会点击页面，但不知道什么时候点击。所以我们订阅body的click事件，当body被点击的时候，body节点便会向订阅者发布这个消息。

当然我们还可以随意移除订阅者，通过`removeEventListener`事件。

## 4.自定义事件

除了内置的DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何js的代码中。现在来实现一个简单的发布订阅模式。

1.  首先需要一个发布者对象
2.  发布者需要维护一个缓存列表，用于存放订阅者的订阅函数。
3.  订阅者可以往事件列表添加一个事件，表示订阅。
4.  发布消息的时候，遍历事件列表，去执行所有事件。

```
const publish = {}; // 发布者
publish.clientList = []; // 事件列表

 // 订阅者往事件列表添加事件
publish.listen = function(fn) {
  this.clientList.push(fn);
}
// 发布者发布事件
publish.trigger = function(...args) {
  this.clientList.forEach(event => {
    event.apply(publish, args);
  })
}

publish.listen((area, price) => {
  console.log(area, price); // 60 120
});
publish.trigger('60', '120');
复制代码
```

这是最简单的发布订阅模式了。但是它存在一个问题，它没有区分订阅类型。比如小a只需要订阅一个60平米的房子，而小b需要订阅一个80平米的房子。但是在上述代码中，并没有区分，接下来改写一下。

```
const publish = {}; // 发布者
publish.clientList = {}; // 事件列表
publish.listen = function(type, fn) {
  // 订阅者往事件列表添加事件
  if (!this.clientList[type]) {
    this.clientList[type] = [];
  }
  this.clientList[type].push(fn);
};
publish.trigger = function(type, ...args) {
  const fns = this.clientList[type];
  if (!fns || fns.length === 0) {
    return false;
  }
  fns.forEach(fn => {
    fn.apply(publish, args);
  });
};

publish.listen('60', price => {
  console.log(price); // 120
});
publish.trigger('60', '120');
复制代码
```

现在可以对订阅的事件类型加以区分了。


## 7.必须先订阅后发布吗

上面的例子中，都是先订阅后发布的。如果先发布后订阅，那么会导致订阅者收不到发布者的消息。

在某些情况下，我们需要将发布的消息保存下来，当有订阅者来订阅的时候，再重新把消息发送给订阅者。当售楼处发给小a消息的时候，如果小a的手机关机，那么在小a开机后应该仍然能收到这条消息，而不是这条消息消失了。

为了满足这个场景，我们需要创建一个存放离线消息的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，那么就将发布时间的动作包裹在一个函数中，这个函数将会被存入堆栈中。等到有订阅者来订阅这个事件的时候，就遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，一旦订阅者收到事件之后，这些事件就不能再发布了。

## 9.JS实现发布订阅模式的便利性

由于js没有类的概念，所以js中的发布订阅模式和Java中的实现还是有区别的。在Java中实现一个自己的发布订阅模式，通常会把订阅者对象当做引用传入发布者对象中，同时订阅者对象还需哟提供一个名为诸如update的方法，供发布者对象在合适的时机调动。发布者对象的clientList保存的是订阅者对象，而不是js中的函数。如果要移除订阅者，就从clientList中直接移除掉订阅者。在js中，我们通过回调函数的形式来代替传统的发布订阅模式，更加优雅和简单。

## 10.小结

发布订阅者模式在实际开发中非常有用。

发布订阅的优点非常明显，一是时间上的解耦，而是对象间的解耦。

-   时间上的解耦: 在异步编程中，由于无法确定异步加载的时间，有可能订阅事件的模块还没有初始化完毕而异步加载就完成了，发布者就已经发布事件了。通过发布订阅模式，可以将发布者的事件提前保存起来，等到发布者加载完毕再执行。
-   对象间的解耦：发布订阅模式中，发布者和订阅者可以不必知道对方的存在，而是通过中介对象来通信。

发布订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上看，无论是MVC还是MVVM，都少不了发布订阅模式的参与，而且js语言本身也是一门基于事件驱动的语言。

当然，发布订阅模式也不是没有缺点。

-   创建订阅者本身需要一定的时间和内存，而当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。
-   另外，发布订阅模式将对象间完全解耦，如果过度使用的话，对象和对象之间的必要联系就会被掩盖，会导致程序难以追踪和理解。

参考：[https://juejin.im/post/5c44236be51d4511dc72db58](https://juejin.im/post/5c44236be51d4511dc72db58)
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc5NTU0MjQyMF19
-->